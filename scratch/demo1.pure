// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Press F9 to execute the 'go' function...
// Press F10 to run the full test suite

// To get started:  Click the + on the top right in order to create a new userDB of just your datamart


function demo_comments(): Any[*]
{
   // single line
   /*
      multi
    line*/

    'ok';
    let a = 1; let b = 2;
  }


function demo_literals():Any[*]
{
   assertEquals(3, 1 + 2 );
   assertEquals(2, 1 * 2 );
   assertEquals(3.4, 1.1 + 2.3 );

   assert(true);
   assert(!false);
   assert(1 == 0 + 1);

   assertEquals('abc', 'a' + 'b' + 'c');

  'ok';
}


/*
  legend-pure-m3-platform
  string.pure

  TODO : Where is the String type defined ??
*/
function demo_strings():Any[*]
{
    assertEquals('st', 'string1'->substring(0,2));
    assertEquals('ab', 'a' + 'b');
}

function f1(a: Integer[1], b:Integer[1]):Integer[*]
{
  $a + $b;
}

function f2(a: Integer[1], b:Integer[1]):Integer[*]
{
  $a - $b;
}

function demo_function_calls():Any[*]
{
    assertEquals('st', 'string1'->substring(0,2));
    assertEquals('st', substring('string1', 0,2));


    assertEquals(3, f1(1,2));
    assertEquals(-1, 1->f2(2));
}

function demo_lambda_functions():Any[*]
{
    assertEquals(3, {| 1 + 2}->eval());
    assertEquals(6, {x | 1 + 2 + $x}->eval(3));
    assertEquals(6, {x:Integer[1] | 1 + 2 + $x}->eval(3));

    let f1 = {x:Integer[1] | 1 + 2 + $x};
    assertEquals(6, $f1->eval(3));
}

function demo_conditionals():Any[*]
{
  assertEquals(100, if ( 10 > 1, | 100, | 200));

  assertEquals(100,
          if ( 10 > 1,
              | 100,
              | 200)
  );

  assertEquals('> 2',

  if (5 > 2,
    | '> 2',
    | '<= 2'
  )

  );

  assertEquals('> 6',

  if (10 > 5,
    | if ( 10 > 6, |'> 6', |'<= 6'),
    | '<= 5'
  )

  );


assertEquals('> 2',

  if (5 > 10,
    | '> 10',
    | if ( 5 > 2,
         | '> 2',
         | '<= 10')
  )

  );

}

function demo_typematch():Any[*]
{
    let func = {x:Any[1] |
                  $x->match([
                      s:String[1]  | 'is string[1]',
                      i:Integer[1] | 'is int[1]',
                      x:Any[*]     | 'is any[*]'
                  ])
                };

    assertEquals('is string[1]', $func->eval('a'));
    assertEquals('is int[1]', $func->eval(1));
    assertEquals('is any[*]', $func->eval(true));
}

/*
  legend-pure-m3-platform
  collection.pure
*/
function demo_collections():Any[*]
{
    assertEquals([1,2,3], [2,3,1]->sort());

    let cmp = {a:Integer[1], b:Integer[1] | if ($a == $b, |0, | if ($a > $b, | -1, | 1))};
    assertEquals([3,2,1], [2,3,1]->sort($cmp));

    assert([1,2,3]->exists( {x | $x == 2}));
    assert([1,2,3]->forAll( {x | $x > 0}));

    assertEquals(6, [1,2,3]->fold( {x, acc | $acc + $x}, 0));
    assertEquals('abc', ['a', 'b', 'c']->fold( {x, acc | $acc + $x}, ''));


    assertEquals([1,2], [1,2]);
    assertNotEquals([1,2], [2,1]);

    assertEquals([1,2,3], [1,2]->concatenate([3]));
    assertEquals(1, [2,1,3]->at(1));
}

/*
  collection.pure
  testMapCollection.pure
*/
function demo_maps():Any[*]
{
    let m1 = [pair('a',1), pair('b',2)]->newMap();
    assertEquals(2, $m1->keys()->size());
    assertEquals(['a', 'b'], $m1->keys());
    assertEquals([1, 2], $m1->values());

    assertEquals(1, $m1->get('a'));

    let m2 = $m1->put('c', 3);
    assertEquals(3, $m2->get('c'));
}

function demo_groupBy():Any[*]
{
    let m1 = [1,2,3,4,5,6]->groupBy(x | mod($x,2) == 0);
    assertEquals([1,3,5], $m1->get(false).values);
    assertEquals([2,4,6], $m1->get(true).values);
}

Class A
{
  f1: String[1];
  f2: Integer[1];

  f1plus(){ $this.f1 + 'plus' }:String[1];

  f1plusplus(x:String[1]){ $this.f1 +  $x }:String[1];
}

Class B
{
  f1: String[0..1];
  f2: Integer[1];
}

function demo_class():Any[*]
{
    assertEquals('string1', ^A(f1='string1', f2=10).f1);
    assertEquals(10, ^A(f1='string1', f2=10).f2);
    assertEquals('string1plus', ^A(f1='string1', f2=10).f1plus);
    assertEquals('string1foo', ^A(f1='string1', f2=10).f1plusplus('foo'));

    assertEquals([], ^B(f2=10).f1);
}

Class Animal
{
  name: String[1];
  sound(){''}:String[1];
}

Class Cat extends Animal
{
  sound(){'meow'}:String[1];
}

Class Lion extends Animal
{
  sound(){'roar'}:String[1];
}

function demo_class_inherit():Any[*]
{
    let cat = ^Cat(name='tom');
    assertEquals('meow', $cat.sound());

    let lion = ^Lion(name='alex');
    assertEquals('roar', $lion.sound());

    let zoo = [$cat, $lion];
    let func = {x:Animal[1] |
        $x->match([
          c:Cat[1] | 'cat named ' + $c.name,
          l:Lion[1] | 'lion named ' + $l.name
        ])
    };

    let text = $zoo->map( a | $func->eval($a));
    assertEquals(['cat named tom', 'lion named alex'], $text);
}

function demo_reflection_type():Any[*]
{
   assertEquals(Package, ^Package(name='a::b')->type());
   assertEquals(String, 'aaaaa'->type());
   assertEquals(Nil, []->type());
   assertEquals(Integer, [1,2,3]->type());
   assertEquals(Any, [1,2,3, 'a']->type());
   assertEquals(Pair, pair(1,2)->type());
}

Class my::pkg1::RClass1
{
    a:Integer[1];
    b:String[1];
}

Class my::pkg1::RClass2
{
    c:Integer[1];
    d:String[1];
}

/*
  metaExtension.pure
  tests/metaExtension.pure
*/
function demo_reflection_class_properties():Any[*]
{
  // refer to package directly
  assertEquals(Package, my::pkg1->type());

  // refer to package by name
  assertEquals(Package, forgivingPathToElement('my::pkg1')->type());

  let children = forgivingPathToElement('my::pkg1')->toOne()->cast(@Package).children;
  assertEquals(2, $children->size());

  // get all properties of a class
  assertEquals(['a', 'b'], my::pkg1::RClass1->allProperties().name);

  // get a property and introspect
  assertEquals('a', my::pkg1::RClass1->propertyByName('a').name);
  assertEquals(Property, my::pkg1::RClass1->propertyByName('a')->type());
  assertEquals(PureOne, my::pkg1::RClass1->propertyByName('a').multiplicity);
  assertEquals('Integer', my::pkg1::RClass1->propertyByName('a').genericType.rawType.name);
  assertEquals(Integer, my::pkg1::RClass1->propertyByName('a').genericType.rawType);

  assertEquals('a', forgivingPathToElement('my::pkg1::RClass1')->toOne()->cast(@Class<Any>)->propertyByName('a').name);
}

Class my::pkg2::pkg3::D
{
  df1: String[1];
  df2: Boolean[1];
}

Class my::pkg2::C
{
  cf1: String[1];
  cf2: Boolean[1];
}

Class my::pkg2::B
{
  bf1: String[1];
  bf2: String[0..2];
  bf3: my::pkg2::C[2];
}

Class my::pkg2::A
{
  {doc.doc='A field1'}
  af1: Integer[1];
  af2: String[2];
  af3: my::pkg2::B[1];
}

function pad(c:Integer[1]):String[1]
{
  '----'->repeat($c)->joinStrings();
}

function process_property(p: AbstractProperty<Any>[1], counter:Integer[1]): Any[*]
{
  println(pad($counter+1) + ' Property : '  + $p.name->toOne());
  let pName = $p.genericType.rawType.name->toOne();
  let lb = $p.multiplicity.lowerBound.value->toOne()->toString();
  let ub = $p.multiplicity.upperBound.value->toOne()->toString();
  println(pad($counter+2) + ' Type : '  + $pName + '[' + $lb + '..' + $ub + ']');
  println(pad($counter+2) + ' Doc : '  + $p->value4Tag('doc', meta::pure::profiles::doc).value->joinStrings());
  if (!$p.genericType.rawType->toOne()->instanceOf(Class), | '', |
        let x = $p.genericType.rawType->toOne()->cast(@Class<Any>);
        process_class($x, $counter+1);
  );
}

function process_class(class: Class<Any>[1], counter:Integer[1]) : Any[*]
{
  println(pad($counter) + 'Class : ' + $class.name->toOne());
  $class->allProperties()->map(p | $p->process_property($counter));
}

function process_package(pkg: Package[1], counter:Integer[1]) : Any[*]
{
  println(pad($counter) + 'Package : ' + $pkg.name->toOne());
  $pkg.children->map(child:Any[1] | $child->match([
                                      p:Package[1] | process_package($p, $counter+1),
                                      c:Class<Any>[1] | process_class($c, $counter+1),
                                      a:Any[*] | []
                                  ])
                );
}


function demo_class_walk():Any[*]
{
  process_class(my::pkg2::A, 0);
}

function demo_package_walk():Any[*]
{
  let children = forgivingPathToElement('my')->cast(@Package).children;
  $children->map(child:Any[1] | $child->match([
                                      p:Package[1] | process_package($p, 0),
                                      a:Any[*] | []
                                  ])
                );
}

function go():Any[*]
{
    //demo_literals();
    //demo_strings();
    //demo_function_calls();
    //demo_lambda_functions();
    //demo_conditionals();
    //demo_typematch();
    //demo_collections();
    //demo_maps();
    //demo_groupBy();
    //demo_class();
    //demo_class_inherit();
    //demo_reflection_type();
    //demo_reflection_class_properties();
    //demo_class_walk();
    demo_package_walk();
    print('ok',1);
}






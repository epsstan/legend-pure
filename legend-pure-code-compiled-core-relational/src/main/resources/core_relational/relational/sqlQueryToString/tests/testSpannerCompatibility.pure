// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

###Pure
Class meta::relational::spanner::tests::domain::Person
{
   firstName: String[1];
   lastName: String[1];
   age:Integer[1];
   key:Integer[1];
}

Class meta::relational::spanner::tests::domain::Thing
{
   name: String[1];
   id: Integer[1];
}

###Relational
Database meta::relational::spanner::tests::db::spannerDb
(
   Table "persontable" (ID INT PRIMARY KEY, firstName VARCHAR(200), lastName VARCHAR(200), age INT, key INT)
   Schema database1
   (
      Table "thingtable" (ID INT PRIMARY KEY, NAME VARCHAR(200))
   ) 
   
   Join Person_Person("persontable".key = {target}.key)
)

###Mapping
Mapping meta::relational::spanner::tests::mapping::simpleRelationalMappingPersonForSpanner
(
   meta::relational::spanner::tests::domain::Person : Relational
   {
      scope([meta::relational::spanner::tests::db::spannerDb])
      (
         firstName : "persontable".firstName,
         lastName: "persontable".lastName,
         age : @Person_Person|"persontable".key         
      )
   }

   meta::relational::spanner::tests::domain::Thing : Relational
   {
    ~primaryKey
    (
      [meta::relational::spanner::tests::db::spannerDb]database1."thingtable".ID
    )
    ~mainTable [meta::relational::spanner::tests::db::spannerDb]database1."thingtable"
    id: [meta::relational::spanner::tests::db::spannerDb]database1."thingtable".ID,
    name: [meta::relational::spanner::tests::db::spannerDb]database1."thingtable".NAME
  }
      
)

###Pure
import meta::relational::runtime::*;
import meta::relational::metamodel::execute::*;
import meta::relational::mapping::*;
import meta::relational::functions::asserts::*;
import meta::relational::runtime::*;
import meta::relational::tests::model::simple::*;
import meta::relational::tests::*;
import meta::relational::functions::sqlstring::*;
import meta::relational::tests::mapping::sqlFunction::model::domain::*;
import meta::relational::tests::mapping::sqlFunction::model::mapping::*;
import meta::pure::runtime::*;
import meta::pure::profiles::*;

function <<test.BeforePackage>> meta::relational::spanner::tests::setUp():Boolean[1]
{
    true;
}

function meta::relational::spanner::tests::testRuntimeForBQ():Runtime[1]
{
   meta::relational::tests::testRuntime(meta::relational::spanner::tests::db::spannerDb);
}

function <<test.Test>> meta::relational::spanner::tests::tableAndColumnNamesAreQuoted():Boolean[1]
{
   let result = toSQLString(
    |meta::relational::spanner::tests::domain::Person.all()->project([s | $s.age], ['KEY']), 
    meta::relational::spanner::tests::mapping::simpleRelationalMappingPersonForSpanner,
    meta::relational::runtime::DatabaseType.Spanner, 
    meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('select `persontable_d#2_d_m1`.key as `KEY` from `persontable` as `root` left outer join `persontable` as `persontable_d#2_d_m1` on (`root`.key = `persontable_d#2_d_m1`.key)', $result);
}


// TODO : Test this from engine so as to catch assertion failure
function meta::relational::spanner::tests::tableWithNonDefaultSchemaNotSupported():Boolean[1]
{
   let result = toSQLString(
    |meta::relational::spanner::tests::domain::Thing.all()->project([s | $s.id], ['ID']), 
    meta::relational::spanner::tests::mapping::simpleRelationalMappingPersonForSpanner,
    meta::relational::runtime::DatabaseType.Spanner, 
    meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('select `root`.ID as `ID` from database1.`thingtable` as `root`', $result);
}

// TODO : Test this from engine so as to catch assertion failure
function meta::relational::spanner::tests::windowFunctionNotSupported():Boolean[1]
{
   let func = {|meta::relational::tests::model::simple::Person.all()
      ->project([
         col(p |$p.lastName,'lastName') 
         ,col(window(p |$p.firstName ),sortAsc(p |$p.lastName), func(p |$p.age->toOne(), y| $y->average()),'ageAverageWindow')
      ])};
   let result = toSQLString(
     $func, 
     meta::relational::tests::simpleRelationalMappingInc, 
     DatabaseType.Spanner, 
     meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('select `root`.LASTNAME as `lastName`, avg(1.0 * `root`.AGE) OVER (Partition By `root`.FIRSTNAME Order By `root`.LASTNAME ASC) as `ageAverageWindow` from personTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::testGroupByAlias():Boolean[1]
{
    let result = toSQLString(
      |Person.all()->groupBy([p|$p.firstName], [agg(p|$p.age, x|$x->sum())], ['name', 'age']),
      meta::relational::tests::simpleRelationalMapping, 
      DatabaseType.Spanner, 
      meta::pure::router::extension::defaultRelationalExtensions());
    assertEquals('select `root`.FIRSTNAME as `name`, sum(`root`.AGE) as `age` from personTable as `root` group by `name`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::testConcat():Boolean[1]
{
   let result = toSQLString(
    |Person.all()->project([p|$p.name, p|$p.addresses.name], ['name','address']),
    meta::relational::tests::simpleRelationalMapping, 
    DatabaseType.Spanner, 
    meta::pure::router::extension::defaultRelationalExtensions());
    print($result);
   assertSameSQL('select concat(`root`.FIRSTNAME, \' \', `root`.LASTNAME) as `name`, `union_d#5_d_m2`.`addressTableNAME` as `address` from personTable as `root` left outer join (select `addressTable_d#6`.ID as ID, null as ADDRESSID, `addressTable_d#6`.NAME as `addressTableNAME` from addressTable as `addressTable_d#6` UNION ALL select `firmTable_d#8`.ID as ID, `firmTable_d#8`.ADDRESSID as ADDRESSID, `addressTable_d#6_f_d`.NAME as `addressTableNAME` from firmTable as `firmTable_d#8` left outer join addressTable as `addressTable_d#6_f_d` on (`addressTable_d#6_f_d`.ID = `firmTable_d#8`.ADDRESSID)) as `union_d#5_d_m2` on (`union_d#5_d_m2`.ID = `root`.FIRMID or `union_d#5_d_m2`.ID = `root`.ADDRESSID)', $result);

}

function <<test.Test>> meta::relational::spanner::tests::atan2():Boolean[1]
{
   let result = toSQLString(
    |SqlFunctionDemo.all()->project([s | $s.floatATan2Result], ['atan2']),
      meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,
      DatabaseType.Spanner, 
      meta::pure::router::extension::defaultRelationalExtensions());
   assertSameSQL('select atan2(`root`.float1,`root`.int1) as `atan2` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::hour():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.hour], ['hour']),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,
        meta::relational::runtime::DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select extract(hour from `root`.dateTime) as `hour` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::weekofyear():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.week], ['weekofyear']),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,
        meta::relational::runtime::DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select extract(week from `root`.dateTime) as `weekofyear` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::cast():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.string3Integer], ['string3Integer']),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,
        meta::relational::runtime::DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select cast(`root`.string3 as int64) as `string3Integer` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::toString():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.int1String], ['int1String']),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,
        meta::relational::runtime::DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select cast(`root`.int1 as string) as `int1String` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::today():Boolean[1]
{
    let result = toSQLString(
        |Trade.all()->filter(d | $d.date == today())->project(x | $x.date, 'date'),
        meta::relational::tests::simpleRelationalMapping, 
        meta::relational::runtime::DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select `root`.tradeDate as `date` from tradeTable as `root` where `root`.tradeDate = CURRENT_DATE()', $result);
}

function <<test.Test>> meta::relational::spanner::tests::stddev_samp():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.float1StdDevSample], 'stdDevSample'),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,
        meta::relational::runtime::DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select stddev_samp(`root`.int1) as `stdDevSample` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::substring():Boolean[1]
{
    let result = toSQLString(
        |Person.all()->filter(p|$p.firstName->substring(1, 5) == 'John'),
        meta::relational::tests::simpleRelationalMapping, 
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select `root`.ID as `pk_0`, `root`.FIRSTNAME as `firstName`, `root`.AGE as `age`, `root`.LASTNAME as `lastName` from personTable as `root` where substr(`root`.FIRSTNAME, 1, 5) = \'John\'', $result);
}

function <<test.Test>> meta::relational::spanner::tests::second():Boolean[1]
{
    let result = toSQLString(
        |Trade.all()->project([ t | $t.settlementDateTime->cast(@Date)->toOne()->second()], ['second']),
        meta::relational::tests::simpleRelationalMapping, 
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select extract( second from `root`.settlementDateTime) as `second` from tradeTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::rtrim():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.rtrimResult], ['rtrim']),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select rtrim(`root`.string2) as `rtrim` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::round():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.float1Round], ['round']),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select round(`root`.float1, 0) as `round` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::rem():Boolean[1]
{
    let result = toSQLString(
        |Trade.all()->project([t| rem($t.quantity, $t.id)], ['rem']),
        meta::relational::tests::simpleRelationalMapping, 
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select mod(`root`.quantity,`root`.ID) as `rem` from tradeTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::position():Boolean[1]
{
    let result = toSQLString(
        |meta::relational::tests::mapping::propertyfunc::model::domain::Person.all()->project(p|$p.firstName, 'firstName'),
        meta::relational::tests::mapping::propertyfunc::model::mapping::PropertyfuncMapping,
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select substring(`root`.FULLNAME, 0, strpos(\',\', `root`.FULLNAME)-1) as `firstName` from personTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::parseInteger():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.string2Integer], ['parseInteger']),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,      
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select cast(`root`.string2Integer as int64) as `parseInteger` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::parseFloat():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.string2Float], ['string2Float']),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,      
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select cast(`root`.string2float as float64) as `string2Float` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::parseDecimal():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.string2Decimal], ['string2Decimal']),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,      
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select cast(`root`.string2Decimal as decimal) as `string2Decimal` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::now():Boolean[1]
{
    let result = toSQLString(
        |Trade.all()->filter(d | $d.date == now())->project(x | $x.date, 'date'),
        meta::relational::tests::simpleRelationalMapping, 
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select `root`.tradeDate as `date` from tradeTable as `root` where `root`.tradeDate = current_timestamp()', $result);
}

// month same as month number
function <<test.Test>> meta::relational::spanner::tests::monthNumber():Boolean[1]
{
    let result = toSQLString(
        |Trade.all()->project([t| monthNumber($t.settlementDateTime)], ['settlementMonthNumber']),
        meta::relational::tests::simpleRelationalMapping, 
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select extract(month from `root`.settlementDateTime) as `settlementMonthNumber` from tradeTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::mod():Boolean[1]
{
    let result = toSQLString(
        |SqlFunctionDemo.all()->project([s | $s.floatModResult ], ['mod']),
        meta::relational::tests::mapping::sqlFunction::model::mapping::testMapping,      
        DatabaseType.Spanner,         
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select mod(`root`.int1,2) as `mod` from dataTable as `root`', $result);
}

function <<test.Test>> meta::relational::spanner::tests::minute():Boolean[1]
{
    let result = toSQLString(
        |Trade.all()->project([t | $t.settlementDateTime->cast(@Date)->toOne()->minute()],['settlementDateTimeMinute']),
        meta::relational::tests::simpleRelationalMapping, 
        DatabaseType.Spanner, 
        meta::pure::router::extension::defaultRelationalExtensions());  
    assertEquals('select extract(minute from `root`.settlementDateTime) as `settlementDateTimeMinute` from tradeTable as `root`', $result);
}
